## this function returns the number of cross edges of a random cut generated by contracting edges

function random_cut(graph_in)
    
    ## make a local copy
    graph = copy(graph_in)
    
    ## initialize the replacement dictionary
    repl = [key => key for key in keys(graph)]


    while length(graph) > 2
        
        ## take a random vertex
        vertex = [k for k in keys(graph)][rand(1:end)]
        
        ## update vertices (and remove self-connecting edge)
        graph[vertex] = map(x -> repl[x], graph[vertex])
        filter!(x -> x != vertex, graph[vertex])

        ## take a random adjecent vertex (and remove to avoid self-connecting edges)
        adj_vertex = splice!(graph[vertex], rand(1:length(graph[vertex])))

        ## again, update vertices, this time for the adjecent vertex
        graph[adj_vertex] = map(x -> repl[x], graph[adj_vertex])

        ## contract these two vertices
        append!(graph[vertex], graph[adj_vertex])

        ## remove old instance of the adjecent vertex
        delete!(graph, adj_vertex)

        ## from here on out, replace adj_vertex by vertex
        repl[adj_vertex] = vertex

        ## apply replacement to replacement rules themselves to avoid nested replacements
        repl = [key => repl[repl[key]] for key in keys(repl)]

    end

    graph = [vertex => filter(x -> x != vertex, map(x -> repl[x], graph[vertex])) for vertex in keys(graph)]

    length([v for v in values(graph)][1])

end




## load the data:

graph = readdlm("kargerMinCut.txt", '\n')
graph = map(line -> map(parseint, split(line,'\t')), graph)
graph = [arr[1] => arr[2:end] for arr in graph]



## show number of vertices and edges

n = length(graph)
m = sum(map(length, values(graph)))

println("Number of vertices: \t", n)
println("Number of edges: \t", m)



## repeat the random_cut sufficiently many times

imax = n*int(log(n)/log(2));

@time println("\nmin_cut(graph) = ", minimum([random_cut(graph) for i=1:imax]),"\n")









